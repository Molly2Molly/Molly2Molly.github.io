<!-- build time:Thu Dec 24 2020 15:46:53 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>设计模式 | Hexo</title><meta name="description" content="设计模式的优点是被证实的解决方案，Patterns are proven solutions容易复用，Patterns can be easily reused自表达，Patterns can be expressive设计模式的六大原则：SOLID原则单一原则 （SRP）: 实现类要职责单一,一个类只做一件事或者一类事，不要将功能无法划分为一类的揉到一起里氏替换原则（LSP）： 不要破坏继承体系"><meta property="og:type" content="article"><meta property="og:title" content="设计模式"><meta property="og:url" content="https://molly2molly.github.io/设计模式/index.html"><meta property="og:site_name" content="张英姿的博客"><meta property="og:description" content="设计模式的优点是被证实的解决方案，Patterns are proven solutions容易复用，Patterns can be easily reused自表达，Patterns can be expressive设计模式的六大原则：SOLID原则单一原则 （SRP）: 实现类要职责单一,一个类只做一件事或者一类事，不要将功能无法划分为一类的揉到一起里氏替换原则（LSP）： 不要破坏继承体系"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2020-09-07T03:34:53.858Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="设计模式"><meta name="twitter:description" content="设计模式的优点是被证实的解决方案，Patterns are proven solutions容易复用，Patterns can be easily reused自表达，Patterns can be expressive设计模式的六大原则：SOLID原则单一原则 （SRP）: 实现类要职责单一,一个类只做一件事或者一类事，不要将功能无法划分为一类的揉到一起里氏替换原则（LSP）： 不要破坏继承体系"><link rel="canonical" href="https://molly2molly.github.io/设计模式/index.html"><link rel="alternate" href="/atom.xml" title="张英姿的博客" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"></head><body class="main-center theme-green" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/molly2molly" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">张英姿</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">前端工程师</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 苏州, 中国</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="Search"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech=""> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">Home</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">Archives</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">Categories</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">Tags</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">Repository</span></a></li><li class="menu-item menu-item-books"><a href="/books"><i class="icon icon-book-fill"></i> <span class="menu-title">Books</span></a></li><li class="menu-item menu-item-links"><a href="/links"><i class="icon icon-friendship"></i> <span class="menu-title">Links</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">About</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/molly2molly" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">Board</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">Categories</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/D3-js/">D3.js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javascript/">javascript</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/others/">others</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tags</h3><div class="widget-body"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/">TCP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6-javascript/">es6 javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Tag Cloud</h3><div class="widget-body tagcloud"><a href="/tags/React/" style="font-size:13px">React</a> <a href="/tags/TCP/" style="font-size:13px">TCP</a> <a href="/tags/es6-javascript/" style="font-size:13px">es6 javascript</a> <a href="/tags/javascript/" style="font-size:14px">javascript</a> <a href="/tags/markdown/" style="font-size:13px">markdown</a> <a href="/tags/webpack/" style="font-size:13px">webpack</a> <a href="/tags/数据结构/" style="font-size:14px">数据结构</a></div></div><div class="widget"><h3 class="widget-title">Archive</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a><span class="archive-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">Recent Posts</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/" class="title">GridLayout</a></p><p class="item-date"><time datetime="2020-12-24T07:13:47.000Z" itemprop="datePublished">2020-12-24</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/Flexbox/" class="title">Flexbox</a></p><p class="item-date"><time datetime="2020-12-24T06:01:50.000Z" itemprop="datePublished">2020-12-24</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/快速选择/" class="title">快速选择</a></p><p class="item-date"><time datetime="2020-12-14T06:10:04.000Z" itemprop="datePublished">2020-12-14</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/快速排序/" class="title">快速排序</a></p><p class="item-date"><time datetime="2020-12-14T06:10:04.000Z" itemprop="datePublished">2020-12-14</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/栈和队列/" class="title">栈和队列</a></p><p class="item-date"><time datetime="2020-12-07T08:13:41.000Z" itemprop="datePublished">2020-12-07</time></p></div></li></ul></div></div></div></aside><main class="main" role="main"><div class="content"><article id="post-设计模式" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">设计模式</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/设计模式/" class="article-date"><time datetime="2019-07-19T01:45:52.000Z" itemprop="datePublished">2019-07-19</time></a></span> <span class="post-comment"><i class="icon icon-comment"></i> <a href="/设计模式/#comments" class="article-comment-link">Comments</a></span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h3 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h3><ol><li>是被证实的解决方案，Patterns are proven solutions</li><li>容易复用，Patterns can be easily reused</li><li>自表达，Patterns can be expressive</li></ol><h3 id="设计模式的六大原则：SOLID原则"><a href="#设计模式的六大原则：SOLID原则" class="headerlink" title="设计模式的六大原则：SOLID原则"></a>设计模式的六大原则：SOLID原则</h3><ol><li><p><code>单一原则 （SRP）</code>: 实现类要职责单一,一个类只做一件事或者一类事，不要将功能无法划分为一类的揉到一起</p></li><li><p><code>里氏替换原则（LSP）</code>： 不要破坏继承体系，子类可以完全替换掉他们所继承的父类，可以理解为调用父类方法的地方换成子类也可以正常执行调用</p></li><li><p><code>依赖倒置原则（DIP）</code>:如果某套功能或者业务逻辑可能之后会出现并行的另外一种模式或者较大的调整，那不如把这部分逻辑抽象出来，创建一个包含相关方法的抽象类，而实现类继承这个抽象类来重写抽象类中的方法，完成具体的实现，调用这些功能方法的类不需要关心自己调用的这些个方法的具体实现，只管调用这些抽象类中定义好的形式上的方法即可，不与实际实现这些方法的类发生直接依赖关系，方便之后的实现逻辑的替换更改</p></li><li><p><code>接口隔离原则(ISP)</code> : 在设计抽象类的时候要精简单一,白话说就是，A需要依赖B提供的一些方法，A我只用B的3个方法，B就尽量不要给A用不到的方法啦</p></li><li><p><code>迪米特法则（LoD）</code>: 降低耦合,尽量减少对象之间的直接的交互，如果其中一个类需要调用另一个类的某一个方法的话，可通过一个关系类发起这个调用，这样一个模块修改时，就可以最大程度的减少波及</p></li><li><p><code>开放-封闭原则（OCP）</code>: 对扩展开放，对修改关闭，你可以继承扩展我所有的能力，到你手里你想咋改咋改，但是，别动我本人好吗？好的</p></li></ol><h5 id="The-main-purpose-of-refactoring-is-to-fight-technical-debt-It-transforms-a-mess-into-clean-code-and-simple-design"><a href="#The-main-purpose-of-refactoring-is-to-fight-technical-debt-It-transforms-a-mess-into-clean-code-and-simple-design" class="headerlink" title="The main purpose of refactoring is to fight technical debt. It transforms a mess into clean code and simple design."></a>The main purpose of refactoring is to fight technical debt. It transforms a mess into clean code and simple design.</h5><h3 id="Clean-Code"><a href="#Clean-Code" class="headerlink" title="Clean Code"></a>Clean Code</h3><ol><li>clean code is obvious for other programmers</li><li>clean code doesn’t contain duplication</li><li>clean code contains a minimal number of classes and other moving parts</li><li>clean code passes all tests</li><li>clean code is easier and cheaper to maintain</li></ol><h3 id="Causes-of-Technical-debt"><a href="#Causes-of-Technical-debt" class="headerlink" title="Causes of Technical debt"></a>Causes of Technical debt</h3><ol><li>Business pressure</li><li>lack of understanding of the consequences of technical debt</li><li>failing to combat the strict coherence of components</li><li>lack of tests</li><li>lack of document</li><li>lack of interaction between team members</li><li>long-term simultaneous development in several branches</li><li>delayed refactoring</li><li>lack of compliance monitoring</li><li>incompetence</li></ol><h3 id="When-to-refactor"><a href="#When-to-refactor" class="headerlink" title="When to refactor"></a>When to refactor</h3><ol><li>When you’re doing something for the first time, just get it done.</li><li>When you’re doing something similar for the second time, cringe at having to repeat but do the same thing anyway.</li><li>When you’re doing something for the third time, start refactoring.</li></ol><ol><li>创建型模式<ol><li>工厂方法模式</li><li>抽象工厂模式</li><li>生成器模式</li><li>原型模式</li><li>单例模式</li></ol></li><li>结构型模式<ol><li>适配器模式</li><li>桥接模式</li><li>组合模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol></li><li>行为模式<ol><li>责任链模式</li><li>命令模式</li><li>迭代器模式</li><li>中介者模式</li><li>备忘录模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li><li>模板方法模式</li><li>访问者模式</li></ol></li></ol><h3 id="Singleton-单例模式"><a href="#Singleton-单例模式" class="headerlink" title="Singleton 单例模式"></a>Singleton 单例模式</h3><p>单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><h5 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</li><li>如果你需要更加严格地控制全局变量， 可以使用单例模式。</li></ol><h5 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h5><ol><li>在类中添加一个私有静态成员变量用于保存单例实例。</li><li>声明一个公有静态构建方法用于获取单例实例。</li><li>在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</li><li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</li><li>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。</li></ol><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以保证一个类只有一个实例。</li><li>获得了一个指向该实例的全局访问节点。</li><li>仅在首次请求单例对象时对其进行初始化。</li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>违反了<em>单一职责原则</em>。 该模式同时解决了两个问题。</li><li>单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。</li><li>该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。</li><li>单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line">  if (typeof Person.instance === &apos;object&apos;)</span><br><span class="line">    return Person.instance;</span><br><span class="line">  Person.instance = this;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    if (typeof Person.instance === &apos;object&apos;) &#123;</span><br><span class="line">      return Person.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.instance = this;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Factory-工厂模式"><a href="#Factory-工厂模式" class="headerlink" title="Factory 工厂模式"></a>Factory 工厂模式</h3><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><ol><li>简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）<ul><li>违背OCP原则，每次新增新类创建过程，都要修改switch-case或if-else语句</li><li>适用于创建对象较少的情况</li></ul></li><li>工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式<ul><li>工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</li><li>注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象</li></ul></li><li>抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式<ul><li>在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。</li></ul></li></ol><h5 id="工厂方法使用场景："><a href="#工厂方法使用场景：" class="headerlink" title="工厂方法使用场景："></a>工厂方法使用场景：</h5><ol><li>当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。</li><li>如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。</li><li>如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。</li></ol><h5 id="工厂方法实现方式："><a href="#工厂方法实现方式：" class="headerlink" title="工厂方法实现方式："></a>工厂方法实现方式：</h5><ol><li>让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。</li><li>在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。</li><li>在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。 你可能需要在工厂方法中添加临时参数来控制返回的产品类型。</li><li>现在， 为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。</li><li>如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。</li><li>如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。</li></ol><h5 id="工厂方法优点："><a href="#工厂方法优点：" class="headerlink" title="工厂方法优点："></a>工厂方法优点：</h5><ol><li>可以避免创建者和具体产品之间的紧密耦合。</li><li>单一职责原则。 你可以将产品创建代码放在程序的单一位置， 从而使得代码更容易维护。</li><li>开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。</li></ol><h5 id="工厂方法缺点："><a href="#工厂方法缺点：" class="headerlink" title="工厂方法缺点："></a>工厂方法缺点：</h5><ol><li>应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 简单工厂</span><br><span class="line">interface Shape &#123;</span><br><span class="line">  draw(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle implements Shape &#123;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    console.log(&quot;draw Circle&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Rectangle implements Shape &#123;</span><br><span class="line">  draw() &#123;</span><br><span class="line">    console.log(&quot;draw Rectangle&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShapeFactory &#123;</span><br><span class="line">  static getShape(shapeType: string) &#123;</span><br><span class="line">    switch (shapeType) &#123;</span><br><span class="line">      case &quot;CIRCLE&quot;:</span><br><span class="line">        return new Circle();</span><br><span class="line">      case &quot;RECTANGLE&quot;:</span><br><span class="line">        return new Rectangle();</span><br><span class="line">      default:</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const circle = ShapeFactory.getShape(&quot;CIRCLE&quot;);</span><br><span class="line">circle?.draw();</span><br><span class="line">const rectangle = ShapeFactory.getShape(&quot;RECTANGLE&quot;);</span><br><span class="line">rectangle?.draw();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">// 工厂方法</span><br><span class="line"></span><br><span class="line">class Button &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;** Button render **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    console.log(&quot;** Button onClick **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WindowsButton extends Button &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;** WindowsButton render **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    console.log(&quot;** WindowsButton onClick **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HTMLButton extends Button &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;** HTMLButton render **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    console.log(&quot;** HTMLButton onClick **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dialog &#123;</span><br><span class="line">  button: Button;</span><br><span class="line">  createButton(): Button &#123;</span><br><span class="line">    return new Button();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    this.button = this.createButton();</span><br><span class="line">    this.button.render();</span><br><span class="line">    this.button.onClick();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WindowsDialog extends Dialog &#123;</span><br><span class="line">  createButton(): Button &#123;</span><br><span class="line">    return new WindowsButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WebDialog extends Dialog &#123;</span><br><span class="line">  createButton(): Button &#123;</span><br><span class="line">    return new HTMLButton();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Application &#123;</span><br><span class="line">  dialog: Dialog;</span><br><span class="line">  initialize(config:string) &#123;// Windows Web</span><br><span class="line">    switch (config) &#123;</span><br><span class="line">      case &quot;Windows&quot;:</span><br><span class="line">        this.dialog = new WindowsDialog();</span><br><span class="line">        break;</span><br><span class="line">      case &quot;Web&quot;:</span><br><span class="line">        this.dialog = new WebDialog();</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw new Error(&quot;UNKNOW&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    this.dialog.render();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const app = new Application();</span><br><span class="line">app.initialize(&apos;Windows&apos;);</span><br><span class="line">app.render();</span><br><span class="line">app.initialize(&apos;Web&apos;);</span><br><span class="line">app.render();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂</span><br><span class="line">interface Gun &#123;</span><br><span class="line">  shooting(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Bullet &#123;</span><br><span class="line">  load(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface AbstractFactory &#123;</span><br><span class="line">  produceGun(): Gun;</span><br><span class="line">  produceBullet(): Bullet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AK implements Gun &#123;</span><br><span class="line">  shooting() &#123;</span><br><span class="line">    console.log(&quot;shooting with AK&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class M4A1 implements Gun &#123;</span><br><span class="line">  shooting() &#123;</span><br><span class="line">    console.log(&quot;shooting with M4A1&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AKBullet implements Bullet &#123;</span><br><span class="line">  load() &#123;</span><br><span class="line">    console.log(&quot;load bullets with AK&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class M4A1Bullet implements Bullet &#123;</span><br><span class="line">  load() &#123;</span><br><span class="line">    console.log(&quot;load bullets with M4A1&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AKFactory implements AbstractFactory &#123;</span><br><span class="line">  produceGun() &#123;</span><br><span class="line">    return new AK();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  produceBullet() &#123;</span><br><span class="line">    return new AKBullet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class M4A1Factory implements AbstractFactory &#123;</span><br><span class="line">  produceGun() &#123;</span><br><span class="line">    return new M4A1();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  produceBullet() &#123;</span><br><span class="line">    return new M4A1Bullet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const f1 = new AKFactory();</span><br><span class="line">const b1 = f1.produceBullet();</span><br><span class="line">b1.load();</span><br><span class="line">const ak = f1.produceGun();</span><br><span class="line">ak.shooting();</span><br><span class="line">const f2 = new M4A1Factory();</span><br><span class="line">f2.produceGun();</span><br><span class="line">const b2 = f2.produceBullet();</span><br><span class="line">b2.load();</span><br><span class="line">const m4a1 = f1.produceGun();</span><br><span class="line">m4a1.shooting();</span><br></pre></td></tr></table></figure><h3 id="Chain-Of-Resp-责任链模式"><a href="#Chain-Of-Resp-责任链模式" class="headerlink" title="Chain Of Resp 责任链模式"></a>Chain Of Resp 责任链模式</h3><p>责任链按照顺序将请求动态传递给一系列的潜在接收者</p><h5 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>支付逻辑</li><li>中间件</li><li>系列权限检测</li><li>dom事件是特殊的责任链模式，一旦某个handler处理了event，就不继续往下传递request了</li></ol><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol><li>一个对象有多个处理方法，而且可以在运行时决定使用哪些handler</li><li>可以对handler增减个数或改变顺序</li><li>各个handler之间互不影响</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>因是在运行时确定handler的数量和顺序，单元测试时很难预测结果</li><li>无法保证request一定会被处理</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">interface Next &#123;</span><br><span class="line">  exec(products: number[]): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ShoppingCart &#123;</span><br><span class="line">  products: number[] = [];</span><br><span class="line"></span><br><span class="line">  addProduct(p: number) &#123;</span><br><span class="line">    this.products.push(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NumberDiscount &#123;</span><br><span class="line">  next: Next;</span><br><span class="line"></span><br><span class="line">  setNext(fn: Next) &#123;</span><br><span class="line">    this.next = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exec(products: number[]) &#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    if (products.length &gt; 3) result = 0.05;</span><br><span class="line"></span><br><span class="line">    return result + this.next.exec(products);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PriceDiscount &#123;</span><br><span class="line">  next: Next;</span><br><span class="line"></span><br><span class="line">  setNext(fn: Next) &#123;</span><br><span class="line">    this.next = fn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  exec(products: number[]) &#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    const total = products.reduce((a, b) =&gt; a + b);</span><br><span class="line"></span><br><span class="line">    if (total &gt;= 500) result = 0.1;</span><br><span class="line"></span><br><span class="line">    return result + this.next.exec(products);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NoneDiscount &#123;</span><br><span class="line">  exec() &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Discount &#123;</span><br><span class="line">  calc(products: number[]) &#123;</span><br><span class="line">    const ndiscount = new NumberDiscount();</span><br><span class="line">    const pdiscount = new PriceDiscount();</span><br><span class="line">    const none = new NoneDiscount();</span><br><span class="line">    ndiscount.setNext(pdiscount);</span><br><span class="line">    pdiscount.setNext(none);</span><br><span class="line">    return ndiscount.exec(products);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const discount = new Discount();</span><br><span class="line"></span><br><span class="line">const sc = new ShoppingCart();</span><br><span class="line">sc.addProduct(100);</span><br><span class="line">sc.addProduct(100);</span><br><span class="line">sc.addProduct(100);</span><br><span class="line">console.log(discount.calc(sc.products)); // 0</span><br><span class="line"></span><br><span class="line">sc.addProduct(100);</span><br><span class="line">console.log(discount.calc(sc.products)); // 0.05</span><br><span class="line"></span><br><span class="line">sc.addProduct(100);</span><br><span class="line">console.log(discount.calc(sc.products)); // 0.15</span><br></pre></td></tr></table></figure><h3 id="Composite-组合模式"><a href="#Composite-组合模式" class="headerlink" title="Composite 组合模式"></a>Composite 组合模式</h3><h5 id="使用场景：-2"><a href="#使用场景：-2" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当系统的模型可以用tree来描述时可以使用组合模式，通过统一interface遍历所有子节点，不用care子节点是single节点还是composite节点</li></ol><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以利用多态和递归机制更方便地使用复杂树结构</li><li>符合开闭原则。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Component &#123;</span><br><span class="line">  execute(): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Product implements Component &#123;</span><br><span class="line">  price = 0;</span><br><span class="line">  constructor(price: number) &#123;</span><br><span class="line">    this.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  execute() &#123;</span><br><span class="line">    return this.price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Box implements Component &#123;</span><br><span class="line">  children: Component[] = [];</span><br><span class="line"></span><br><span class="line">  add(c: Component) &#123;</span><br><span class="line">    this.children.push(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execute() &#123;</span><br><span class="line">    return this.children.reduce((totalValue, currentCompoent) =&gt; &#123;</span><br><span class="line">      totalValue += currentCompoent.execute();</span><br><span class="line">      return totalValue;</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const phoneBox = new Box();</span><br><span class="line">phoneBox.add(new Product(500));</span><br><span class="line">phoneBox.add(new Product(30));</span><br><span class="line">console.log(phoneBox.execute()); // 530</span><br><span class="line"></span><br><span class="line">const penBox = new Box();</span><br><span class="line">penBox.add(new Product(3));</span><br><span class="line">penBox.add(new Product(3));</span><br><span class="line">penBox.add(new Product(3));</span><br><span class="line">console.log(penBox.execute()); // 9</span><br><span class="line"></span><br><span class="line">const orderBox = new Box();</span><br><span class="line">orderBox.add(phoneBox);</span><br><span class="line">orderBox.add(penBox);</span><br><span class="line">orderBox.add(new Product(3));</span><br><span class="line">console.log(orderBox.execute()); // 542 = 590 + 9 +3</span><br></pre></td></tr></table></figure><h3 id="State-状态模式"><a href="#State-状态模式" class="headerlink" title="State 状态模式"></a>State 状态模式</h3><h5 id="使用场景：-3"><a href="#使用场景：-3" class="headerlink" title="使用场景："></a>使用场景：</h5><p>一个由一个或多个动态变化的属性导致发生不同行为的对象，在与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化，那么这个对象，就是有状态的对象</p><p>代码中包含大量与对象状态有关的条件语句，像是if else或switch case语句，且这些条件执行与否依赖于该对象的状态。</p><p>如果场景符合上面两个条件，那我们就可以想象状态模式是不是可以帮忙了</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h5><ol><li>一个状态状态对应行为，封装在一个类里，更直观清晰，增改方便</li><li>状态与状态间，行为与行为间彼此独立互不干扰</li><li>避免事物对象本身不断膨胀，条件判断语句过多</li><li>每次执行动作不用走很多不必要的判断语句，用哪个拿哪个</li></ol><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>需要将事物的不同状态以及对应的行为拆分出来，有时候会无法避免的拆分的很细，有的时候涉及业务逻辑，一个动作拆分出对应的两个状态，动作就拆不明白了，过度设计</li><li>必然会增加事物类和动作类的个数，有时候动作类再根据单一原则，按照功能拆成几个类，会反而使得代码混乱，可读性降低</li></ol><h5 id="State状态模式之一有限状态机模型一般都具有以下特点："><a href="#State状态模式之一有限状态机模型一般都具有以下特点：" class="headerlink" title="State状态模式之一有限状态机模型一般都具有以下特点："></a>State状态模式之一有限状态机模型一般都具有以下特点：</h5><ol><li>状态总数是有限的</li><li>任一时刻，只处在一种状态之中</li><li>某种条件触发后，会从一种状态转变到另一种状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">interface State &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  next(): State | void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LoadedSuccessState implements State &#123;</span><br><span class="line">  name = &quot;LoadedSuccess&quot;;</span><br><span class="line">  next() &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LoadedErrorState implements State &#123;</span><br><span class="line">  name = &quot;LoadedError&quot;;</span><br><span class="line">  next() &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LoadingState implements State &#123;</span><br><span class="line">  name = &quot;Loading&quot;;</span><br><span class="line">  next() &#123;</span><br><span class="line">    const random = Math.random();</span><br><span class="line">    if (random &gt;= 0.5) &#123;</span><br><span class="line">      return new LoadedSuccessState();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return new LoadedErrorState();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StartState implements State &#123;</span><br><span class="line">  name = &quot;Start&quot;;</span><br><span class="line">  next() &#123;</span><br><span class="line">    return new LoadingState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Context &#123;</span><br><span class="line">  currentState: State | void = new StartState();</span><br><span class="line"></span><br><span class="line">  nextState() &#123;</span><br><span class="line">    if (this.currentState) &#123;</span><br><span class="line">      this.currentState = this.currentState.next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getState() &#123;</span><br><span class="line">    return this.currentState ? this.currentState.name : &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const ctx = new Context();</span><br><span class="line">while (ctx.getState()) &#123;</span><br><span class="line">  console.log(ctx.getState());</span><br><span class="line">  ctx.nextState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bridge-桥接模式"><a href="#Bridge-桥接模式" class="headerlink" title="Bridge 桥接模式"></a>Bridge 桥接模式</h3><p>桥接模式是一种结构型设计模式，桥接模式通过将继承改为组合的方式将类在不同维度上扩展，具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。</p><p>桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。</p><h5 id="使用场景：-4"><a href="#使用场景：-4" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。桥接模式可以将庞杂类拆分为几个类层次结构。此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。</li><li>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</li><li>如果你需要在运行时切换不同实现方法， 可使用桥接模式。</li></ol><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以创建与平台无关的类和程序</li><li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息</li><li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响</li><li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节</li></ol><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>对高内聚的类使用该模式可能会让代码更加复杂</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">interface Device &#123;</span><br><span class="line">  isEnable(): boolean;</span><br><span class="line">  enable(): void;</span><br><span class="line">  disable(): void;</span><br><span class="line">  setVolume(percent: number): void;</span><br><span class="line">  getVolume(): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Remote &#123;</span><br><span class="line">  device: Device;</span><br><span class="line">  constructor(device: Device) &#123;</span><br><span class="line">    this.device = device;</span><br><span class="line">  &#125;</span><br><span class="line">  togglePower() &#123;</span><br><span class="line">    if (this.device.isEnable()) &#123;</span><br><span class="line">      this.device.disable();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.device.enable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  volumeUp() &#123;</span><br><span class="line">    this.device.setVolume(Math.min(this.device.getVolume() + 2, 100));</span><br><span class="line">  &#125;</span><br><span class="line">  volumeDown() &#123;</span><br><span class="line">    this.device.setVolume(Math.max(this.device.getVolume() - 2, 0));</span><br><span class="line">  &#125;</span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    return this.device.getVolume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Radio implements Device &#123;</span><br><span class="line">  enableStatus = false;</span><br><span class="line">  volume = 0;</span><br><span class="line"></span><br><span class="line">  isEnable() &#123;</span><br><span class="line">    return this.enableStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  enable() &#123;</span><br><span class="line">    this.enableStatus = true;</span><br><span class="line">  &#125;</span><br><span class="line">  disable() &#123;</span><br><span class="line">    this.enableStatus = false;</span><br><span class="line">  &#125;</span><br><span class="line">  setVolume(percent: number) &#123;</span><br><span class="line">    this.volume = percent;</span><br><span class="line">  &#125;</span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    return this.volume;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TV implements Device &#123;</span><br><span class="line">  enableStatus = false;</span><br><span class="line">  volume = 0;</span><br><span class="line"></span><br><span class="line">  isEnable() &#123;</span><br><span class="line">    return this.enableStatus;</span><br><span class="line">  &#125;</span><br><span class="line">  enable() &#123;</span><br><span class="line">    this.enableStatus = true;</span><br><span class="line">  &#125;</span><br><span class="line">  disable() &#123;</span><br><span class="line">    this.enableStatus = false;</span><br><span class="line">  &#125;</span><br><span class="line">  setVolume(percent: number) &#123;</span><br><span class="line">    this.volume = percent;</span><br><span class="line">  &#125;</span><br><span class="line">  getVolume() &#123;</span><br><span class="line">    return this.volume;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const radioRemote = new Remote(new Radio());</span><br><span class="line">radioRemote.togglePower();</span><br><span class="line">radioRemote.volumeUp();</span><br><span class="line">radioRemote.volumeUp();</span><br><span class="line">console.log(radioRemote.getVolume());</span><br><span class="line"></span><br><span class="line">const tvRemote = new Remote(new TV());</span><br><span class="line">tvRemote.togglePower();</span><br><span class="line">tvRemote.volumeUp();</span><br><span class="line">tvRemote.volumeUp();</span><br><span class="line">tvRemote.volumeDown();</span><br><span class="line">console.log(tvRemote.getVolume());</span><br></pre></td></tr></table></figure><h3 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy 策略模式"></a>Strategy 策略模式</h3><p>策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。<br>名为上下文的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。<br>因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。</p><h5 id="使用场景：-5"><a href="#使用场景：-5" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</li><li>当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。将不同行为抽取到一个独立类层次结构中， 并将原始类组合成同一个， 从而减少重复代码。</li><li>如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</li><li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。</li></ol><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以在运行时切换对象内的算法</li><li>可以将算法的实现和使用算法的代码隔离开来</li><li>可以使用组合来代替继承</li><li>开闭原则。 你无需对上下文进行修改就能够引入新的策略</li></ol><h5 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>如果你的算法极少发生改变， 那么没有任何理由引入新的类和接口。 使用该模式只会让程序过于复杂。</li><li>客户端必须知晓策略间的不同——它需要选择合适的策略。</li><li>许多现代编程语言支持函数类型功能， 允许你在一组匿名函数中实现不同版本的算法。 这样， 你使用这些函数的方式就和使用策略对象时完全相同， 无需借助额外的类和接口来保持代码简洁。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">interface RouteStrategy &#123;</span><br><span class="line">  buildRoute(A: string, B: string): string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RoadStrategy implements RouteStrategy &#123;</span><br><span class="line">  buildRoute(A: string, B: string) &#123;</span><br><span class="line">    return A + &quot; to &quot; + B + &quot; : 1 -&gt; 2 -&gt; 3&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WalkingStrategy implements RouteStrategy &#123;</span><br><span class="line">  buildRoute(A: string, B: string) &#123;</span><br><span class="line">    return A + &quot; to &quot; + B + &quot; : 1 -&gt; 4 -&gt; 3&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PublicTransportStrategy implements RouteStrategy &#123;</span><br><span class="line">  buildRoute(A: string, B: string) &#123;</span><br><span class="line">    return A + &quot; to &quot; + B + &quot; : 1 -&gt; 5 -&gt; 3&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MapNavigator &#123;</span><br><span class="line">  routeStrategy: RouteStrategy;</span><br><span class="line">  setRouteStrategy(routeStrategy: RouteStrategy) &#123;</span><br><span class="line">    this.routeStrategy = routeStrategy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const navi = new MapNavigator();</span><br><span class="line">navi.setRouteStrategy(new RoadStrategy());</span><br><span class="line">console.log(navi.routeStrategy.buildRoute(&quot;A&quot;, &quot;B&quot;));</span><br><span class="line">navi.setRouteStrategy(new WalkingStrategy());</span><br><span class="line">console.log(navi.routeStrategy.buildRoute(&quot;C&quot;, &quot;D&quot;));</span><br><span class="line">navi.setRouteStrategy(new PublicTransportStrategy());</span><br><span class="line">console.log(navi.routeStrategy.buildRoute(&quot;E&quot;, &quot;F&quot;));</span><br></pre></td></tr></table></figure><h3 id="Adapter-适配器模式"><a href="#Adapter-适配器模式" class="headerlink" title="Adapter 适配器模式"></a>Adapter 适配器模式</h3><p>适配器模式是一种结构型设计模式，适配器模式通常在已有程序中使用，它能使接口不兼容的对象能够相互合作。</p><p>适配器能为被封装对象提供不同的接口，适配器模式会试图运用已有的接口。 适配器通常只封装一个对象，</p><h5 id="使用场景：-6"><a href="#使用场景：-6" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类</li><li>如果需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性,将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。</li></ol><h5 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h5><ol><li>单一职责原则，你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li><li>开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li></ol><h5 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li></ol><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">interface Round &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">  getRadius(): number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 圆钉 */</span><br><span class="line">class RoundPeg implements Round &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">  constructor(radius: number) &#123;</span><br><span class="line">    this.radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  getRadius() &#123;</span><br><span class="line">    return this.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 方钉 */</span><br><span class="line">class SquarePeg &#123;</span><br><span class="line">  width: number;</span><br><span class="line">  constructor(width: number) &#123;</span><br><span class="line">    this.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  getWidth() &#123;</span><br><span class="line">    return this.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 圆孔 */</span><br><span class="line">class RoundHole implements Round &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">  constructor(radius: number) &#123;</span><br><span class="line">    this.radius = radius;</span><br><span class="line">  &#125;</span><br><span class="line">  getRadius() &#123;</span><br><span class="line">    return this.radius;</span><br><span class="line">  &#125;</span><br><span class="line">  fits(peg: Round): boolean &#123;</span><br><span class="line">    return peg.getRadius() &lt;= this.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 方钉适配器以适应圆孔 */</span><br><span class="line">class SquarePegAdapter implements Round &#123;</span><br><span class="line">  peg: SquarePeg;</span><br><span class="line">  radius: number;</span><br><span class="line">  constructor(peg: SquarePeg) &#123;</span><br><span class="line">    this.peg = peg;</span><br><span class="line">    this.radius = (this.peg.getWidth() * Math.sqrt(2)) / 2;</span><br><span class="line">  &#125;</span><br><span class="line">  getRadius(): number &#123;</span><br><span class="line">    return this.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const roundPeg = new RoundPeg(10);</span><br><span class="line">console.log(roundPeg.getRadius());</span><br><span class="line">const roundHole = new RoundHole(10);</span><br><span class="line">console.log(roundHole.fits(roundPeg)); </span><br><span class="line"></span><br><span class="line">const squarePeg = new SquarePeg(14);</span><br><span class="line">const squarePegAdapter = new SquarePegAdapter(squarePeg);</span><br><span class="line">console.log(squarePegAdapter.getRadius());</span><br><span class="line">console.log(roundHole.fits(squarePegAdapter));</span><br></pre></td></tr></table></figure><h3 id="Decorator-装饰模式"><a href="#Decorator-装饰模式" class="headerlink" title="Decorator 装饰模式"></a>Decorator 装饰模式</h3><p>装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><p>装饰模式还支持递归组合</p><p>装饰能为对象提供加强的接口</p><h5 id="使用场景：-7"><a href="#使用场景：-7" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式</li><li>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式</li></ol><h5 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h5><ol><li>无需创建新子类即可扩展对象的行为</li><li>可以在运行时添加或删除对象的功能</li><li>可以用多个装饰封装对象来组合几种行为</li><li>单一职责原则，可以将实现了许多不同行为的一个大类拆分为多个较小的类</li></ol><h5 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>在封装器栈中删除特定封装器比较困难</li><li>实现行为不受装饰栈顺序影响的装饰比较困难</li><li>各层的初始化配置代码看上去可能会很糟糕</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Notifier &#123;</span><br><span class="line">  send(msg: string) &#123;</span><br><span class="line">    console.log(&quot;Notifier : &quot; + msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaseDecorator implements Notifier &#123;</span><br><span class="line">  wrapper: Notifier;</span><br><span class="line">  constructor(wrapper: Notifier) &#123;</span><br><span class="line">    this.wrapper = wrapper;</span><br><span class="line">  &#125;</span><br><span class="line">  send(msg: string) &#123;</span><br><span class="line">    this.wrapper.send(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SMSDecorator extends BaseDecorator &#123;</span><br><span class="line">  send(msg: string) &#123;</span><br><span class="line">    super.send(msg);</span><br><span class="line">    console.log(&quot;SMSDecorator : &quot; + msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WechatDecorator extends BaseDecorator &#123;</span><br><span class="line">  send(msg: string) &#123;</span><br><span class="line">    super.send(msg);</span><br><span class="line">    console.log(&quot;WechatDecorator : &quot; + msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class QQDecorator extends BaseDecorator &#123;</span><br><span class="line">  send(msg: string) &#123;</span><br><span class="line">    super.send(msg);</span><br><span class="line">    console.log(&quot;QQDecorator : &quot; + msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let notifier = new Notifier();</span><br><span class="line">notifier = new SMSDecorator(notifier);</span><br><span class="line">notifier = new WechatDecorator(notifier);</span><br><span class="line">notifier = new QQDecorator(notifier);</span><br><span class="line">notifier.send(&quot;HELLO&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">&apos;Notifier : HELLO&apos;</span><br><span class="line">&apos;SMSDecorator : HELLO&apos;</span><br><span class="line">&apos;WechatDecorator : HELLO&apos;</span><br><span class="line">&apos;QQDecorator : HELLO&apos;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="Proxy-代理模式"><a href="#Proxy-代理模式" class="headerlink" title="Proxy 代理模式"></a>Proxy 代理模式</h3><p>代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p><p>代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。</p><p>代理模式能为对象提供相同的接口</p><h5 id="使用场景：-8"><a href="#使用场景：-8" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。无需在程序启动时就创建该对象， 可将对象的初始化延迟到真正有需要的时候。</li><li>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。代理可仅在客户端凭据满足要求时将请求传递给服务对象。</li><li>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。在这种情形中， 代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。</li><li>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</li><li>缓存请求结果 （缓存代理）。 适用于需要缓存客户请求结果并对缓存生命周期进行管理时， 特别是当返回结果的体积非常大时。</li><li>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</li></ol><h5 id="优点：-7"><a href="#优点：-7" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以在客户端毫无察觉的情况下控制服务对象。</li><li>如果客户端对服务对象的生命周期没有特殊要求， 你可以对生命周期进行管理。</li><li>即使服务对象还未准备好或不存在， 代理也可以正常工作。</li><li>开闭原则。 你可以在不对服务或客户端做出修改的情况下创建新代理。</li></ol><h5 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>代码可能会变得复杂， 因为需要新建许多类。</li><li>服务响应可能会延迟。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">interface DB &#123;</span><br><span class="line">  getData(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySql implements DB &#123;</span><br><span class="line">  getData() &#123;</span><br><span class="line">    console.log(&quot;** getData **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySqlProxy implements DB &#123;</span><br><span class="line">  db: MySql;</span><br><span class="line">  constructor(db: MySql) &#123;</span><br><span class="line">    this.db = db;</span><br><span class="line">  &#125;</span><br><span class="line">  getData() &#123;</span><br><span class="line">    console.log(&quot;** somthing done before **&quot;);</span><br><span class="line">    this.db.getData();</span><br><span class="line">    console.log(&quot;** somthing done after **&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const proxy = new MySqlProxy(new MySql());</span><br><span class="line">proxy.getData();</span><br></pre></td></tr></table></figure><h3 id="Facade-外观模式"><a href="#Facade-外观模式" class="headerlink" title="Facade 外观模式"></a>Facade 外观模式</h3><p>外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。</p><p>外观模式为现有对象定义了一个新接口，外观通常会作用于整个对象子系统上。</p><h5 id="使用场景：-9"><a href="#使用场景：-9" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。子系统通常会随着时间的推进变得越来越复杂。 即便是应用了设计模式， 通常你也会创建更多的类。 尽管在多种情形中子系统可能是更灵活或易于复用的， 但其所需的配置和样板代码数量将会增长得更快。 为了解决这个问题， 外观将会提供指向子系统中最常用功能的快捷方式， 能够满足客户端的大部分需求。</li><li>如果需要将子系统组织为多层结构， 可以使用外观。创建外观来定义子系统中各层次的入口。 你可以要求子系统仅使用外观来进行交互， 以减少子系统之间的耦合。</li></ol><h5 id="优点：-8"><a href="#优点：-8" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以让自己的代码独立于复杂子系统。</li></ol><h5 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>外观可能成为与程序中所有类都耦合的上帝对象。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class ShopFacade &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.discount = new Discount();</span><br><span class="line">    this.shipping = new Shipping();</span><br><span class="line">    this.fees = new Fees();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  calc(price) &#123;</span><br><span class="line">    price = this.discount.calc(price);</span><br><span class="line">    price = this.fees.calc(price);</span><br><span class="line">    price += this.shipping.calc();</span><br><span class="line">    return price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Discount &#123;</span><br><span class="line"></span><br><span class="line">  calc(value) &#123;</span><br><span class="line">    return value * 0.9;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shipping &#123;</span><br><span class="line">  calc() &#123;</span><br><span class="line">    return 5;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fees &#123;</span><br><span class="line"></span><br><span class="line">  calc(value) &#123;</span><br><span class="line">    return value * 1.05;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mediator-中介者模式"><a href="#Mediator-中介者模式" class="headerlink" title="Mediator 中介者模式"></a>Mediator 中介者模式</h3><p>中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p><h5 id="使用场景：-10"><a href="#使用场景：-10" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</li><li>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</li><li>如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。由于所有组件间关系都被包含在中介者中， 因此你无需修改组件就能方便地新建中介者类以定义新的组件合作方式。</li></ol><h5 id="优点：-9"><a href="#优点：-9" class="headerlink" title="优点："></a>优点：</h5><ol><li>单一职责原则。 你可以将多个组件间的交流抽取到同一位置， 使其更易于理解和维护</li><li>开闭原则。 你无需修改实际组件就能增加新的中介者</li><li>可以减轻应用中多个组件间的耦合情况</li><li>可以更方便地复用各个组件</li></ol><h5 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>一段时间后， 中介者可能会演化成为上帝对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class TrafficTower &#123;</span><br><span class="line">  airplanes: Airplane[] = [];</span><br><span class="line"></span><br><span class="line">  requestPositions() &#123;</span><br><span class="line">    return this.airplanes.map(airplane =&gt; &#123;</span><br><span class="line">      return airplane.position;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Airplane &#123;</span><br><span class="line">  position: number;</span><br><span class="line">  trafficTower: TrafficTower;</span><br><span class="line">  constructor(position: number, trafficTower: TrafficTower) &#123;</span><br><span class="line">    this.position = position;</span><br><span class="line">    this.trafficTower = trafficTower;</span><br><span class="line">    this.trafficTower.airplanes.push(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestPositions() &#123;</span><br><span class="line">    return this.trafficTower.requestPositions();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const trafficTower = new TrafficTower();</span><br><span class="line">const boeing1 = new Airplane(10, trafficTower);</span><br><span class="line">const boeing2 = new Airplane(15, trafficTower);</span><br><span class="line">const boeing3 = new Airplane(55, trafficTower);</span><br><span class="line">boeing1.requestPositions(); // [10, 15, 55]</span><br></pre></td></tr></table></figure><h3 id="Observer-观察者模式"><a href="#Observer-观察者模式" class="headerlink" title="Observer 观察者模式"></a>Observer 观察者模式</h3><p>观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><h5 id="使用场景：-11"><a href="#使用场景：-11" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式</li><li>当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用</li></ol><h5 id="优点：-10"><a href="#优点：-10" class="headerlink" title="优点："></a>优点：</h5><ol><li>开闭原则。 你无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）</li><li>可以在运行时建立对象之间的联系</li></ol><h5 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>订阅者的通知顺序是随机的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Subscriber &#123;</span><br><span class="line">  update(ctx: Publisher): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Publisher &#123;</span><br><span class="line">  state: string[] = [];</span><br><span class="line">  subscribers: Subscriber[] = [];</span><br><span class="line">  subscribe(s: Subscriber) &#123;</span><br><span class="line">    if (!this.subscribers.find(subscribe =&gt; subscribe === s)) &#123;</span><br><span class="line">      this.subscribers.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  unsubscribe(s: Subscriber) &#123;</span><br><span class="line">    this.subscribers = this.subscribers.filter(subscribe =&gt; subscribe !== s);</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    this.subscribers.forEach(s =&gt; s.update(this));</span><br><span class="line">  &#125;</span><br><span class="line">  stateChange() &#123;</span><br><span class="line">    const newState = Math.random();</span><br><span class="line">    this.state.push(newState.toFixed(2));</span><br><span class="line">    this.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Subscriber1 implements Subscriber &#123;</span><br><span class="line">  update(ctx: Publisher) &#123;</span><br><span class="line">    console.log(&quot;Subscriber1 get : &quot; + ctx.state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Subscriber2 implements Subscriber &#123;</span><br><span class="line">  update(ctx: Publisher) &#123;</span><br><span class="line">    console.log(&quot;Subscriber2 get : &quot; + ctx.state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const publisher = new Publisher();</span><br><span class="line">const s1 = new Subscriber1();</span><br><span class="line">publisher.subscribe(s1);</span><br><span class="line">const s2 = new Subscriber2();</span><br><span class="line">publisher.subscribe(s2);</span><br><span class="line">publisher.stateChange();</span><br><span class="line">publisher.unsubscribe(s2);</span><br><span class="line">publisher.stateChange();</span><br></pre></td></tr></table></figure><h3 id="Command-命令模式"><a href="#Command-命令模式" class="headerlink" title="Command 命令模式"></a>Command 命令模式</h3><p>命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><p>命令模式建议将请求的所有细节 （例如调用的对象、 方法名称和参数列表） 抽取出来组成命令类， 该类中仅包含一个用于触发请求的方法。</p><h5 id="使用场景：-12"><a href="#使用场景：-12" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果你需要通过操作来参数化对象， 可使用命令模式。命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、 将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</li><li>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后， 该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。</li><li>如果你想要实现操作回滚功能， 可使用命令模式。</li></ol><h5 id="优点：-11"><a href="#优点：-11" class="headerlink" title="优点："></a>优点：</h5><ol><li>单一职责原则。 你可以解耦触发和执行操作的类。</li><li>开闭原则。 你可以在不修改已有客户端代码的情况下在程序中创建新的命令。</li><li>可以实现撤销和恢复功能。</li><li>可以实现操作的延迟执行。</li><li>可以将一组简单命令组合成一个复杂命令。</li></ol><h5 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>代码可能会变得更加复杂， 因为你在发送者和接收者之间增加了一个全新的层次。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">interface Command &#123;</span><br><span class="line">  /* execute 无参数*/</span><br><span class="line">  execute(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 具体命令 执行：委托业务类操作*/</span><br><span class="line">class OnCommand implements Command &#123;</span><br><span class="line">  turbine: Turbine;</span><br><span class="line">  argumentState = false;</span><br><span class="line">  constructor(turbine: Turbine, argumentState: boolean) &#123;</span><br><span class="line">    this.turbine = turbine;</span><br><span class="line">    this.argumentState = argumentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execute() &#123;</span><br><span class="line">    this.turbine.setState(this.argumentState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class OffCommand implements Command &#123;</span><br><span class="line">  turbine: Turbine;</span><br><span class="line">  argumentState = false;</span><br><span class="line">  constructor(turbine: Turbine, argumentState: boolean) &#123;</span><br><span class="line">    this.turbine = turbine;</span><br><span class="line">    this.argumentState = argumentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execute() &#123;</span><br><span class="line">    this.turbine.setState(this.argumentState);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 接收者：业务类 */</span><br><span class="line">class Turbine &#123;</span><br><span class="line">  state = false;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.state = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setState(state: boolean) &#123;</span><br><span class="line">    this.state = state;</span><br><span class="line">    console.log(this.state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 发送者 */</span><br><span class="line">class Cockpit &#123;</span><br><span class="line">  command: Command;</span><br><span class="line">  constructor(command: Command) &#123;</span><br><span class="line">    this.setCommand(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setCommand(command: Command) &#123;</span><br><span class="line">    this.command = command;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executeCommand() &#123;</span><br><span class="line">    this.command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 客户端 创建并配置具体命令*/</span><br><span class="line">const turbine = new Turbine();</span><br><span class="line">const onCommand = new OnCommand(turbine, true);</span><br><span class="line">const cockpit = new Cockpit(onCommand);</span><br><span class="line">cockpit.executeCommand();</span><br><span class="line">const offCommand = new OffCommand(turbine, false);</span><br><span class="line">cockpit.setCommand(offCommand);</span><br><span class="line">cockpit.executeCommand();</span><br></pre></td></tr></table></figure><h3 id="Visitor-访问者模式"><a href="#Visitor-访问者模式" class="headerlink" title="Visitor 访问者模式"></a>Visitor 访问者模式</h3><p>访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。</p><p>访问者模式建议将新行为放入一个名为访问者的独立类中， 而不是试图将其整合到已有类中。</p><h5 id="使用场景：-13"><a href="#使用场景：-13" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。</li><li>可使用访问者模式来清理辅助行为的业务逻辑。该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。</li><li>当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。</li></ol><h5 id="优点：-12"><a href="#优点：-12" class="headerlink" title="优点："></a>优点：</h5><ol><li>开闭原则。 你可以引入在不同类对象上执行的新行为， 且无需对这些类做出修改。</li><li>单一职责原则。 可将同一行为的不同版本移到同一个类中。</li><li>访问者对象可以在与各种对象交互时收集一些有用的信息。 当你想要遍历一些复杂的对象结构 （例如对象树）， 并在结构中的每个对象上应用访问者时， 这些信息可能会有所帮助。</li></ol><h5 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>每次在元素层次结构中添加或移除一个类时， 你都要更新所有的访问者。</li><li>在访问者同某个元素进行交互时， 它们可能没有访问元素私有成员变量和方法的必要权限。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">interface Visitor &#123;</span><br><span class="line">  visit(e: VisitorTarget): void;</span><br><span class="line">&#125;</span><br><span class="line">interface VisitorTarget &#123;</span><br><span class="line">  accept(v: Visitor): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee implements VisitorTarget &#123;</span><br><span class="line">  bonus = 0;</span><br><span class="line">  salary = 0;</span><br><span class="line">  constructor(salary: number) &#123;</span><br><span class="line">    this.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  accept(visitor: Visitor) &#123;</span><br><span class="line">    visitor.visit(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Manager extends Employee &#123;</span><br><span class="line">  constructor(salary: number) &#123;</span><br><span class="line">    super(salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Developer extends Employee &#123;</span><br><span class="line">  constructor(salary: number) &#123;</span><br><span class="line">    super(salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BonusVisitor implements Visitor &#123;</span><br><span class="line">  visit(e: VisitorTarget) &#123;</span><br><span class="line">    if (e instanceof Manager) &#123;</span><br><span class="line">      e.bonus = e.salary * 2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (e instanceof Developer) &#123;</span><br><span class="line">      e.bonus = e.salary;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const employees = [];</span><br><span class="line">const john = new Developer(4000);</span><br><span class="line">const maria = new Developer(4000);</span><br><span class="line">const christian = new Manager(10000);</span><br><span class="line">employees.push(john);</span><br><span class="line">employees.push(maria);</span><br><span class="line">employees.push(christian);</span><br><span class="line"></span><br><span class="line">const bonusVisitor = new BonusVisitor();</span><br><span class="line">employees.forEach(e =&gt; &#123;</span><br><span class="line">  e.accept(bonusVisitor);</span><br><span class="line">  console.log(e.bonus);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Iterator-迭代器模式"><a href="#Iterator-迭代器模式" class="headerlink" title="Iterator 迭代器模式"></a>Iterator 迭代器模式</h3><p>迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p><h5 id="使用场景：-14"><a href="#使用场景：-14" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</li><li>使用该模式可以减少程序中重复的遍历代码。</li><li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</li></ol><h5 id="优点：-13"><a href="#优点：-13" class="headerlink" title="优点："></a>优点：</h5><ol><li>单一职责原则。 通过将体积庞大的遍历算法代码抽取为独立的类， 你可对客户端代码和集合进行整理。</li><li>开闭原则。 你可实现新型的集合和迭代器并将其传递给现有代码， 无需修改现有代码。</li><li>你可以并行遍历同一集合， 因为每个迭代器对象都包含其自身的遍历状态。</li><li>相似的， 你可以暂停遍历并在需要时继续。</li></ol><h5 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>如果你的程序只与简单的集合进行交互， 应用该模式可能会矫枉过正。</li><li>对于某些特殊集合， 使用迭代器可能比直接遍历的效率低。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">interface CIterator &#123;</span><br><span class="line">  next(): number;</span><br><span class="line">  hasNext(): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface CIterableCollection &#123;</span><br><span class="line">  createIterator(): CIterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CArray implements CIterableCollection &#123;</span><br><span class="line">  elements: number[] = [];</span><br><span class="line"></span><br><span class="line">  constructor(elements: number[]) &#123;</span><br><span class="line">    this.elements = elements;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createIterator() &#123;</span><br><span class="line">    let index = 0</span><br><span class="line">    return &#123;</span><br><span class="line">      next: () =&gt; &#123;</span><br><span class="line">        return this.elements[index++];</span><br><span class="line">      &#125;,</span><br><span class="line">      hasNext: () =&gt; &#123;</span><br><span class="line">        return index &lt; this.elements.length;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = new CArray([1, 2, 3, 4, 5]);</span><br><span class="line">const iterator = arr.createIterator();</span><br><span class="line">console.log(iterator.next());</span><br><span class="line"></span><br><span class="line">console.log(&apos;******&apos;);</span><br><span class="line"></span><br><span class="line">const iterator2= arr.createIterator();</span><br><span class="line">while (iterator2.hasNext()) &#123;</span><br><span class="line">  console.log(iterator2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memento-备忘录模式"><a href="#Memento-备忘录模式" class="headerlink" title="Memento 备忘录模式"></a>Memento 备忘录模式</h3><p>备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><p>备忘录模式将创建状态快照 （Snapshot） 的工作委派给实际状态的拥有者原发器 （Originator） 对象。 这样其他对象就不再需要从 “外部” 复制编辑器状态了， 编辑器类拥有其状态的完全访问权， 因此可以自行生成快照。</p><p>模式建议将对象状态的副本存储在一个名为备忘录 （Memento） 的特殊对象中。 除了创建备忘录的对象外， 任何对象都不能访问备忘录的内容。 其他对象必须使用受限接口与备忘录进行交互， 它们可以获取快照的元数据 （创建时间和操作名称等）， 但不能获取快照中原始对象的状态。</p><p>这种限制策略允许你将备忘录保存在通常被称为负责人 （Caretakers） 的对象中。 由于负责人仅通过受限接口与备忘录互动， 故其无法修改存储在备忘录内部的状态。 同时， 原发器拥有对备忘录所有成员的访问权限， 从而能随时恢复其以前的状态。</p><h5 id="使用场景：-15"><a href="#使用场景：-15" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。</li><li>当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。</li></ol><h5 id="优点：-14"><a href="#优点：-14" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以在不破坏对象封装情况的前提下创建对象状态快照。</li><li>可以通过让负责人维护原发器状态历史记录来简化原发器代码。</li></ol><h5 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>如果客户端过于频繁地创建备忘录， 程序将消耗大量内存。</li><li>负责人必须完整跟踪原发器的生命周期， 这样才能销毁弃用的备忘录。</li><li>绝大部分动态编程语言 （例如 PHP、 Python 和 JavaScript） 不能确保备忘录中的状态不被修改。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">interface MementoState &#123;</span><br><span class="line">  from: number;</span><br><span class="line">  to: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Memento &#123;</span><br><span class="line">  state: MementoState;</span><br><span class="line">  constructor(state: MementoState) &#123;</span><br><span class="line">    this.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  getState() &#123;</span><br><span class="line">    return this.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Originator &#123;</span><br><span class="line">  state: MementoState = &#123; from: 0, to: 1 &#125;;</span><br><span class="line"></span><br><span class="line">  store() &#123;</span><br><span class="line">    return new Memento(this.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  restore(m: Memento | undefined) &#123;</span><br><span class="line">    if (!m) return;</span><br><span class="line">    this.state = m.getState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Caretaker &#123;</span><br><span class="line">  originator: Originator;</span><br><span class="line">  history: Memento[] = [];</span><br><span class="line"></span><br><span class="line">  constructor(originator: Originator) &#123;</span><br><span class="line">    this.originator = originator;</span><br><span class="line">    this.save();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  save() &#123;</span><br><span class="line">    const m = this.originator.store();</span><br><span class="line">    this.history.push(m);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doSomething() &#123;</span><br><span class="line">    this.originator.state = &#123;</span><br><span class="line">      from: Math.floor(Math.random() * 100),</span><br><span class="line">      to: Math.floor(Math.random() * 100)</span><br><span class="line">    &#125;;</span><br><span class="line">    this.save();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  undo() &#123;</span><br><span class="line">    const m = this.history.pop();</span><br><span class="line">    this.originator.restore(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new Caretaker(new Originator());</span><br><span class="line">console.log(&quot;origin&quot;, c.originator.state);</span><br><span class="line">c.doSomething();</span><br><span class="line">console.log(&quot;save&quot;, c.originator.state);</span><br><span class="line">c.doSomething();</span><br><span class="line">console.log(&quot;save&quot;, c.originator.state);</span><br><span class="line">c.undo();</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br><span class="line">c.undo();</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br><span class="line">c.undo();</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br><span class="line">c.undo();</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br></pre></td></tr></table></figure><h5 id="命令模式-备忘录模式"><a href="#命令模式-备忘录模式" class="headerlink" title="命令模式 + 备忘录模式"></a>命令模式 + 备忘录模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">interface MementoState &#123;</span><br><span class="line">  from: number;</span><br><span class="line">  to: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Memento &#123;</span><br><span class="line">  state: MementoState;</span><br><span class="line">  constructor(state: MementoState) &#123;</span><br><span class="line">    this.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  getState() &#123;</span><br><span class="line">    return this.state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Originator &#123;</span><br><span class="line">  state: MementoState = &#123; from: 0, to: 1 &#125;;</span><br><span class="line"></span><br><span class="line">  store() &#123;</span><br><span class="line">    return new Memento(this.state);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  restore(m: Memento | undefined) &#123;</span><br><span class="line">    if (!m) return;</span><br><span class="line">    this.state = m.getState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Command &#123;</span><br><span class="line">  execute(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SaveCommand implements Command &#123;</span><br><span class="line">  c: Caretaker;</span><br><span class="line">  constructor(c: Caretaker) &#123;</span><br><span class="line">    this.c = c;</span><br><span class="line">  &#125;</span><br><span class="line">  execute() &#123;</span><br><span class="line">    const m = this.c.originator.store();</span><br><span class="line">    this.c.history.push(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class UndoCommand implements Command &#123;</span><br><span class="line">  c: Caretaker;</span><br><span class="line">  constructor(c: Caretaker) &#123;</span><br><span class="line">    this.c = c;</span><br><span class="line">  &#125;</span><br><span class="line">  execute() &#123;</span><br><span class="line">    const m = this.c.history.pop();</span><br><span class="line">    this.c.originator.restore(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Caretaker &#123;</span><br><span class="line">  originator: Originator;</span><br><span class="line">  history: Memento[] = [];</span><br><span class="line"></span><br><span class="line">  constructor(originator: Originator) &#123;</span><br><span class="line">    this.originator = originator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  doSomething() &#123;</span><br><span class="line">    this.originator.state = &#123;</span><br><span class="line">      from: Math.floor(Math.random() * 100),</span><br><span class="line">      to: Math.floor(Math.random() * 100)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  executeCommand(command: Command) &#123;</span><br><span class="line">    command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const c = new Caretaker(new Originator());</span><br><span class="line">const saveCommand = new SaveCommand(c);</span><br><span class="line">const undoCommand = new UndoCommand(c);</span><br><span class="line">c.executeCommand(saveCommand);</span><br><span class="line">console.log(&quot;origin&quot;, c.originator.state);</span><br><span class="line">c.doSomething();</span><br><span class="line">c.executeCommand(saveCommand);</span><br><span class="line">console.log(&quot;save&quot;, c.originator.state);</span><br><span class="line">c.doSomething();</span><br><span class="line">c.executeCommand(saveCommand);</span><br><span class="line">console.log(&quot;save&quot;, c.originator.state);</span><br><span class="line">c.executeCommand(undoCommand);</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br><span class="line">c.executeCommand(undoCommand);</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br><span class="line">c.executeCommand(undoCommand);</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br><span class="line">c.executeCommand(undoCommand);</span><br><span class="line">console.log(&quot;undo&quot;, c.originator.state);</span><br></pre></td></tr></table></figure><h3 id="Prototype-原型模式"><a href="#Prototype-原型模式" class="headerlink" title="Prototype 原型模式"></a>Prototype 原型模式</h3><p>原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。</p><p>原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 克隆方法。</p><h5 id="使用场景：-16"><a href="#使用场景：-16" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。</li><li>如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。</li></ol><h5 id="优点：-15"><a href="#优点：-15" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以克隆对象， 而无需与它们所属的具体类相耦合。</li><li>可以克隆预生成原型， 避免反复运行初始化代码。</li><li>可以更方便地生成复杂对象。</li><li>可以用继承以外的方式来处理复杂对象的不同配置。</li></ol><h5 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>克隆包含循环引用的复杂对象可能会非常麻烦。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">interface Prototype &#123;</span><br><span class="line">  clone(): Prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sheep implements Prototype &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  tags: number[];</span><br><span class="line"></span><br><span class="line">  constructor(name: string, tags: number[]) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.tags = tags;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clone() &#123;</span><br><span class="line">    return new Sheep(this.name, this.tags);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sheep = new Sheep(&quot;dolly&quot;, [1, 2, 3]);</span><br><span class="line">const dolly = sheep.clone();</span><br><span class="line">console.log(dolly.name === sheep.name); // true</span><br><span class="line">console.log(dolly.tags === sheep.tags); // true</span><br><span class="line">sheep.tags.push(4);</span><br><span class="line">console.log(dolly.tags) // [1, 2, 3, 4]</span><br><span class="line">sheep.tags = [];</span><br><span class="line">console.log(dolly.tags) // [1, 2, 3, 4]</span><br><span class="line">console.log(dolly instanceof Sheep); // true</span><br><span class="line">console.log(dolly === sheep); // false</span><br></pre></td></tr></table></figure><h3 id="Builder-生成器模式"><a href="#Builder-生成器模式" class="headerlink" title="Builder 生成器模式"></a>Builder 生成器模式</h3><p>生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p><p>生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为生成器的独立对象中。</p><p>该模式会将对象构造过程划分为一组步骤。 每次创建对象时， 你都需要通过生成器对象执行一系列步骤。 重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。</p><p>当你需要创建不同形式的产品时， 其中的一些构造步骤可能需要不同的实现。在这种情况下， 你可以创建多个不同的生成器， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些生成器 （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p><p>基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 同时， 主管类将负责管理制造步骤的顺序。</p><h5 id="使用场景：-17"><a href="#使用场景：-17" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>使用生成器模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。</li><li>当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。</li><li>使用生成器构造组合树或其他复杂对象。</li></ol><h5 id="优点：-16"><a href="#优点：-16" class="headerlink" title="优点："></a>优点：</h5><ol><li>可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。</li><li>生成不同形式的产品时， 你可以复用相同的制造代码。</li><li>单一职责原则。 你可以将复杂构造代码从产品的业务逻辑中分离出来。</li></ol><h5 id="缺点-16"><a href="#缺点-16" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class HTTPRequest &#123;</span><br><span class="line">  url = &quot;&quot;;</span><br><span class="line">  method = &quot;&quot;;</span><br><span class="line">  payload: &#123;&#125; = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RequestBuilder &#123;</span><br><span class="line">  request: HTTPRequest;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.request = new HTTPRequest();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  forUrl(url: string) &#123;</span><br><span class="line">    this.request.url = url;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useMethod(method: string) &#123;</span><br><span class="line">    this.request.method = method;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  payload(payload: &#123;&#125;) &#123;</span><br><span class="line">    this.request.payload = payload;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    return this.request;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const requestBuilder = new RequestBuilder();</span><br><span class="line">const url = &quot;http://something/users&quot;;</span><br><span class="line">const method = &quot;GET&quot;;</span><br><span class="line">const request = requestBuilder</span><br><span class="line">  .forUrl(url)</span><br><span class="line">  .useMethod(method)</span><br><span class="line">  .payload(&#123; a: 1 &#125;)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure><h3 id="Flyweight-享元模式"><a href="#Flyweight-享元模式" class="headerlink" title="Flyweight 享元模式"></a>Flyweight 享元模式</h3><p>享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p><h5 id="使用场景：-18"><a href="#使用场景：-18" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</li></ol><h5 id="优点：-17"><a href="#优点：-17" class="headerlink" title="优点："></a>优点：</h5><ol><li>如果程序中有很多相似对象， 那么你将可以节省大量内存。</li></ol><h5 id="缺点-17"><a href="#缺点-17" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>可能需要牺牲执行速度来换取内存， 因为他人每次调用享元方法时都需要重新计算部分情景数据。</li><li>代码会变得更加复杂。 团队中的新成员总是会问： ​ “为什么要像这样拆分一个实体的状态？”。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Color &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorFactory &#123;</span><br><span class="line">  colors: &#123; [prop: string]: Color &#125;;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.colors = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  create(name: string) &#123;</span><br><span class="line">    const color = this.colors[name];</span><br><span class="line">    if (color) return color;</span><br><span class="line">    this.colors[name] = new Color(name);</span><br><span class="line">    return this.colors[name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const cf = new ColorFactory();</span><br><span class="line">cf.create(&quot;RED&quot;);</span><br><span class="line">cf.create(&quot;RED&quot;);</span><br><span class="line">cf.create(&quot;RED&quot;);</span><br><span class="line">cf.create(&quot;YELLOW&quot;);</span><br><span class="line">cf.create(&quot;YELLOW&quot;);</span><br><span class="line">console.log(cf.colors); // &#123; RED: Color &#123; name: &apos;RED&apos; &#125;, YELLOW: Color &#123; name: &apos;YELLOW&apos; &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="Template-Method-模板方法模式"><a href="#Template-Method-模板方法模式" class="headerlink" title="Template Method 模板方法模式"></a>Template Method 模板方法模式</h3><p>模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><p>模板方法模式建议将算法分解为一系列步骤， 然后将这些步骤改写为方法， 最后在 “模板方法” 中依次调用这些方法。 步骤可以是 抽象的， 也可以有一些默认的实现。 为了能够使用算法， 客户端需要自行提供子类并实现所有的抽象步骤。 如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。</p><h5 id="使用场景：-19"><a href="#使用场景：-19" class="headerlink" title="使用场景："></a>使用场景：</h5><ol><li>当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</li><li>当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</li></ol><h5 id="优点：-18"><a href="#优点：-18" class="headerlink" title="优点："></a>优点：</h5><ol><li>可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。</li><li>可将重复代码提取到一个超类中。</li></ol><h5 id="缺点-18"><a href="#缺点-18" class="headerlink" title="缺点:"></a>缺点:</h5><ol><li>部分客户端可能会受到算法框架的限制。</li><li>通过子类抑制默认步骤实现可能会导致违反<em>里氏替换原则</em>。</li><li>模板方法中的步骤越多， 其维护工作就可能会越困难。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Tax &#123;</span><br><span class="line">  value: number;</span><br><span class="line">  calc(value: number) &#123;</span><br><span class="line">    if (value &gt;= 1000) value = this.overThousand(value);</span><br><span class="line"></span><br><span class="line">    return this.complementaryFee(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  complementaryFee(value: number) &#123;</span><br><span class="line">    return value + 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  overThousand(value: number) &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tax1 extends Tax &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  overThousand(value: number) &#123;</span><br><span class="line">    return value * 1.1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Tax2 extends Tax &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  overThousand(value: number) &#123;</span><br><span class="line">    return value * 1.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tax1 = new Tax1();</span><br><span class="line">const tax2 = new Tax2();</span><br><span class="line"></span><br><span class="line">console.log(tax1.calc(1000)); // 1110</span><br><span class="line">console.log(tax2.calc(1000)); // 1210</span><br><span class="line">console.log(tax2.calc(100)); // 110</span><br></pre></td></tr></table></figure><h5 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h5><ol><li><a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#introduction" target="_blank" rel="noopener">https://addyosmani.com/resources/essentialjsdesignpatterns/book/#introduction</a></li><li><a href="http://www.code4human.com/state-pattern-javascript-example/" target="_blank" rel="noopener">http://www.code4human.com/state-pattern-javascript-example/</a></li><li><a href="https://segmentfault.com/a/1190000015050674" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015050674</a></li><li><a href="https://refactoring.guru/design-patterns/" target="_blank" rel="noopener">https://refactoring.guru/design-patterns/</a></li></ol></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="https://molly2molly.github.io/设计模式/" title="设计模式" target="_blank" rel="external">https://molly2molly.github.io/设计模式/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/molly2molly" target="_blank" class="img-burn thumb-sm visible-lg"><img src="/images/avatar.jpg" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/molly2molly" target="_blank"><span class="text-dark">张英姿</span><small class="ml-1x">前端工程师</small></a></h3><div>梦里寻他千百度 蓦然回首 那人却在灯火阑珊处</div></div></figure></div></div></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom=""><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/防抖debounce和节流throttle/" title="防抖debounce和节流throttle"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a></li><li class="next"><a href="/ServerSideRendering/" title="ServerSideRendering"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>Maybe you could buy me a cup of coffee.</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p></div><div role="tabpanel" class="tab-pane fade" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan"></div><p class="text-muted mv">Scan this qrcode</p><p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a></li><li role="presentation"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/molly2molly" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright"><div class="publishby">Theme by <a href="https://github.com/cofess" target="_blank">cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>!function(T){var n={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)"},ROOT_URL:"/",CONTENT_URL:"/content.json"};T.INSIGHT_CONFIG=n}(window)</script><script src="/js/insight.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta="nick,mail,link";meta=meta.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"",appKey:"",placeholder:"Just go go",avatar:"mm",meta:meta,pageSize:"10",visitor:!1})</script></body></html><!-- rebuild by neat -->